# Диаграмма компонентов:
![image](https://github.com/Yemetry/Software-Architecture/assets/107578601/8a1b74e7-da22-4afd-8f0c-18ee6dd3864b)

![image](https://github.com/Yemetry/Software-Architecture/assets/107578601/a8996f6e-c1b6-4e11-bbaa-bf43ced89ea4)


# Модель базы данных

![image](https://github.com/Yemetry/Software-Architecture/assets/107578601/a6776a63-bcd3-45de-a05e-bd2a10a81dab)


 Краткое пояснение к модели базы данных:

- users: Содержит информацию о пользователях.
- presentations: Представляет собой презентации и ссылается на пользователя, создавшего их.
- slides: Содержит информацию о слайдах презентаций, включая их содержимое и тип (информационный или вопрос).
- questions: Хранит открытые вопросы, связанные с конкретными слайдами.
- quiz_responses: Содержит ответы на вопросы викторины с указанием правильности.
- options: Хранит варианты ответов на вопросы, связанные с конкретными вопросами. Включает в себя идентификатор варианта ответа, идентификатор вопроса, текст варианта ответа и флаг правильности ответа.
- answers: Объединение информации из таблиц text_responses и image_responses. Хранит ответы на вопросы, независимо от их типа (текстовый или с изображением). Каждый ответ связан с конкретным пользователем, презентацией и вопросом. Содержит идентификатор ответа, идентификатор пользователя, идентификатор презентации, идентификатор вопроса, текстовый ответ и URL изображения (если применимо).




# Код с учетом принципов KISS, YAGNI, DRY и SOLID.
```
# server.py (FastAPI)

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List

app = FastAPI()

class Report(BaseModel):
    user_id: int
    presentation_id: int
    slide_id: int
    response: str
    is_correct: bool

reports_db = []

@app.post("/reports", response_model=Report)
async def create_report(report: Report):
    reports_db.append(report)
    return report

@app.get("/reports/{user_id}", response_model=List[Report])
async def get_user_reports(user_id: int):
    user_reports = [report for report in reports_db if report.user_id == user_id]
    if not user_reports:
        raise HTTPException(status_code=404, detail="Reports not found for this user")
    return user_reports

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], 
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000)

// ApiService.js (Vue.js)

import axios from 'axios';

const API_URL = 'http://localhost:8000'; // Измените на ваш URL API

const ApiService = {
  async fetchUserReports(userId) {
    try {
      const response = await axios.get(`${API_URL}/reports/${userId}`);
      return response.data;
    } catch (error) {
      throw error;
    }
  },
};

export default ApiService;

<!-- App.vue (Vue.js) -->

<template>
  <div id="app">
    <h1>User Reports</h1>
    <ul>
      <li v-for="report in reports" :key="report.id">
        User ID: {{ report.user_id }}, Slide ID: {{ report.slide_id }}, Response: {{ report.response }}, Correct: {{ report.is_correct }}
      </li>
    </ul>
  </div>
</template>

<script>
import ApiService from './services/ApiService.js';

export default {
  data() {
    return {
      reports: [],
    };
  },
  mounted() {
    ApiService.fetchUserReports(1)
      .then(reports => {
        this.reports = reports;
      })
      .catch(error => {
        console.error('Error fetching user reports:', error);
      });
  },
};
</script>

<style>
#app {
  text-align: center;
  margin-top: 20px;
}

ul {
  list-style-type: none;
  padding: 0;
}

li {
  margin: 10px 0;
}
</style>
```

Пояснение:

- KISS (Keep It Simple, Stupid): Код написан просто и понятно. В FastAPI, мы используем минимальный набор инструментов для обработки HTTP-запросов и создания отчетов. В Vue.js, компонент App.vue прост и легко читаем.

- YAGNI (You Ain't Gonna Need It): Мы добавляем только те функции, которые действительно необходимы для текущего функционала. Например, не добавляются сложные механизмы аутентификации или авторизации, если они не требуются в текущем контексте.

- DRY (Don't Repeat Yourself): Код организован так, чтобы избежать повторения. Например, базовый URL для HTTP-запросов в Vue.js определен один раз, и его можно легко изменить в одном месте.

- SOLID: Принципы SOLID следованы в структуре кода FastAPI, где каждая функция выполняет одну задачу, и в Vue.js, где компонент App.vue ответственен только за отображение данных и управление жизненным циклом компонента.
- Принцип единственной ответственности (Single Responsibility Principle, SRP):
   Весь код, как на стороне сервера (FastAPI), так и на стороне клиента (Vue.js), разделен на компоненты с единой ответственностью. Например:
   Серверный код (FastAPI) разделен на два основных компонента: логика обработки запросов и миддлваре для обработки CORS.
   Клиентский код (Vue.js) также разделен на два компонента: компонент для отображения отчетов пользователей и сервис для взаимодействия с API.
   Каждый компонент отвечает только за одну задачу и несет только одну ответственность.
- Принцип открытости/закрытости (Open/Closed Principle, OCP):
   Код построен таким образом, что его можно расширять, но не изменять. Например:
   В FastAPI, при необходимости добавить новые методы или функциональность, можно легко создать новые обработчики маршрутов без изменения существующих.
   В Vue.js, если требуется добавить новый функционал взаимодействия с API, можно легко создать новый сервис или расширить существующий без изменения компонента.
- Принцип подстановки Лиско (Liskov Substitution Principle, LSP):
   Хотя в данном коде нет явной иерархии наследования классов, все компоненты используют интерфейсы (например, взаимодействие с API через интерфейс ApiService), что обеспечивает возможность легкой замены одной реализации    другой без изменения клиентского кода.
- Принцип разделения интерфейса (Interface Segregation Principle, ISP):
   Интерфейсы в данном коде разделены на маленькие, специфичные и согласованные с конкретными клиентами. Например:
   В FastAPI, разделен интерфейс для работы с отчетами пользователей и интерфейс для работы с CORS.
   В Vue.js, создан интерфейс для сервиса взаимодействия с API.
- Принцип инверсии зависимостей (Dependency Inversion Principle, DIP):
   Весь код написан с учетом принципа инверсии зависимостей, где зависимости определены через абстракции, а не через конкретные реализации. Например:
   В FastAPI, зависимость от обработчиков маршрутов определена через интерфейс обработки запросов.
   В Vue.js, зависимость от сервиса взаимодействия с API определена через интерфейс ApiService.

# Иные принципы разработки:

## BDUF (Big Design Up Front)
**Масштабное проектирование прежде всего**
- Описание: BDUF подразумевает создание детального проекта до начала реализации.
- Применение к коду: Данный код не является результатом BDUF, так как он реализует функциональность по мере необходимости без предварительного детального проектирования.
- Отказываетесь или применяете: BDUF может привести к излишней сложности и избыточному проектированию, особенно на ранних этапах разработки, когда еще не полностью понятны требования и потребности пользователей. Создание минимального набора функциональности позволяет избежать излишней сложности и сосредоточиться на самых важных аспектах проекта.
## PoC (Proof of Concept):
**Доказательство концепции**
- Описание: Этот принцип предполагает создание минимальной реализации, чтобы продемонстрировать, что концепция работает.
- Применение к коду: Данный код можно рассматривать как PoC, так как он представляет минимальную реализацию API для отчетов пользователей и простой интерфейс для их отображения.

## MVP (Minimum Viable Product):
**Минимально жизнеспособный продукт**
- Описание: MVP представляет собой продукт с минимальным набором функций, достаточным для удовлетворения первоначальных потребностей пользователей.
- Применение к коду: Данный код также соответствует концепции MVP, так как реализует базовый функционал для создания отчетов и просмотра отчетов пользователей.

## SoC (Separation of Concerns):
**Принцип разделения ответственности**
- Описание: SoC означает разделение кода на логические компоненты, каждый из которых отвечает за отдельный аспект функциональности.
- Применение к коду: В текущем коде логика обработки запросов и логика отображения данных разделены. Однако, стоит отметить, что более четкое разделение компонентов могло бы быть достигнуто, например, с помощью разделения API-логики и логики отображения на серверной и клиентской сторонах соответственно.

